---
alwaysApply: false
---
# Nuxt 3 資料獲取技術指南

簡短描述：本文件專注於 Nuxt 3 資料獲取的技術實作細節，包括 useFetch vs $fetch 的選擇策略、快取控制、SSR 安全性等技術層面的最佳實踐。

最後更新：2024-12-19

> **注意**：完整的 API 開發規範請參考 `api-development-spec.mdc`，本檔案專注於資料獲取的技術細節。

---

## 技術選擇原則

### useFetch vs $fetch 技術差異

| 特性 | useFetch | $fetch |
|------|----------|--------|
| 快取機制 | ✅ 內建快取 | ❌ 無快取 |
| SSR 支援 | ✅ 完整支援 | ⚠️ 需手動處理 |
| Reactive 狀態 | ✅ pending, error, data | ❌ 需手動管理 |
| 重複請求防護 | ✅ key 參數控制 | ❌ 無防護 |
| 記憶體使用 | ⚠️ 較高（狀態管理） | ✅ 較低 |
| 執行時機控制 | ✅ immediate, watch | ❌ 需手動控制 |

### 技術決策樹

```
需要快取嗎？
├─ 是 → useFetch
└─ 否 → 需要 SSR 嗎？
    ├─ 是 → useFetch
    └─ 否 → 需要載入狀態嗎？
        ├─ 是 → useFetch
        └─ 否 → $fetch
```

---

## 進階配置參數

### useFetch 關鍵參數說明

```typescript
const { data, pending, error, execute, refresh } = useFetch(url, {
  key: 'unique-key',        // 快取唯一識別
  server: true,            // SSR 階段是否執行
  immediate: true,          // 是否立即執行
  watch: false,             // 是否監聽參數變化
  default: () => ({}),      // 預設值
  transform: (data) => data, // 資料轉換函數
  pick: ['field1'],        // 只選取特定欄位
  getCachedData: (key) => {}, // 自定義快取邏輯
})
```

### 快取控制策略

#### 1. Key 命名規範
```typescript
// ✅ 好的命名
key: 'user-profile-123'
key: 'company-programs-page-1'

// ❌ 避免的命名
key: 'data'
key: 'fetch'
```

#### 2. 快取生命週期
```typescript
// 手動清除快取
const { clear } = useFetch('/api/data', { key: 'my-data' })
clear() // 清除特定快取

// 全域清除快取
await clearNuxtData() // 清除所有快取
await clearNuxtData('my-data') // 清除特定快取
```

#### 3. 條件性快取
```typescript
const shouldCache = computed(() => authStore.isLoggedIn)

const { data } = useFetch('/api/protected', {
  key: 'protected-data',
  server: false,
  immediate: shouldCache.value, // 根據條件決定是否執行
})
```

---

## 常見問題與解決方案

### 1. SSR 水合不匹配
```typescript
// ❌ 問題：服務端和客戶端資料不一致
const { data } = useFetch('/api/data', {
  server: true, // 服務端執行
  // 但客戶端可能因為認證狀態不同而得到不同結果
})

// ✅ 解決：明確區分 SSR 和客戶端行為
const { data } = useFetch('/api/data', {
  server: false, // 僅在客戶端執行
  key: 'client-only-data'
})
```

### 2. 重複請求問題
```typescript
// ❌ 問題：多個組件同時請求相同資料
// Component A
const { data } = useFetch('/api/user', { key: 'user' })
// Component B  
const { data } = useFetch('/api/user', { key: 'user' }) // 重複請求

// ✅ 解決：使用相同的 key 共享快取
const { data } = useFetch('/api/user', { key: 'user-profile' })
```

### 3. 記憶體洩漏
```typescript
// ❌ 問題：未清理的監聽器
const { data } = useFetch('/api/data', {
  watch: [reactiveParam],
  // 組件銷毀時可能未清理
})

// ✅ 解決：使用 onUnmounted 清理
onUnmounted(() => {
  clearNuxtData('my-cache-key')
})
```

---

## 效能優化技巧

### 1. 預載入策略
```typescript
// 預載入可能需要的資料
const { data: prefetchData } = await useFetch('/api/preload', {
  key: 'preload-data',
  server: true,
  immediate: false
})
```

### 2. 分頁資料處理
```typescript
const { data, pending } = useFetch('/api/items', {
  key: `items-page-${currentPage.value}`,
  watch: [currentPage],
  transform: (data) => ({
    items: data.items,
    total: data.total,
    hasMore: data.items.length === 20
  })
})
```

### 3. 錯誤重試機制
```typescript
const { data, error, execute } = useFetch('/api/unreliable', {
  key: 'retry-data',
  retry: 3, // 自動重試 3 次
  retryDelay: 1000 // 重試間隔 1 秒
})
```

---

## 技術注意事項

- **記憶體管理**：定期清理不需要的快取，避免記憶體洩漏
- **SSR 一致性**：確保服務端和客戶端資料一致，避免水合不匹配
- **Key 命名**：使用有意義且唯一的 key 名稱，避免快取衝突
- **效能監控**：監控 Core Web Vitals，確保資料獲取不影響使用者體驗
- **錯誤處理**：建立統一的錯誤處理機制，提供良好的使用者回饋

---

## 相關文件

- **API 開發規範**：`api-development-spec.mdc` - 完整的 API 開發流程
- **效能優化指南**：`fe-performance-optimization.mdc` - 前端效能最佳實踐
- **JavaScript 風格指南**：`fe-JavaScript-style-guide.mdc` - 程式碼風格規範