---
alwaysApply: false
---
# 每次修改本檔案時，都檢查全部範圍內是否存在多處語焉不詳(敘述模糊，請補充具體感)、語意衝突(後話和前話化打架)。如果發現後請指出並與我討論修改內容的去留。

# Nuxt 3 資料獲取與快取策略指南

簡短描述：本文件定義了 Nuxt 3 專案中資料獲取的標準做法，包括 useFetch vs $fetch 的選擇策略、快取控制、SSR 安全性等最佳實踐。

最後更新：2024-09-28

---

## 核心原則

- **Store 中優先使用 useFetch**：在 Pinia store 中應使用 useFetch 而非 $fetch，提供內建快取機制避免重複請求
- **快取策略明確**：針對不同資料特性選擇適當的快取策略，平衡效能與資料新鮮度
- **SSR 安全性**：確保服務端和客戶端資料一致，避免水合不匹配問題
- **狀態管理整合**：將資料獲取與 reactive 狀態管理良好整合，提供清晰的載入狀態

## useFetch vs $fetch 選擇指南

### 使用 useFetch 的情況

- **Store 中的資料獲取**：提供快取、key 控制、reactive 狀態
- **需要 SSR 支援**：確保伺服器端預載資料
- **需要載入狀態**：利用 pending、error 等 reactive 狀態
- **相對穩定的資料**：如使用者資訊、設定資料

### 使用 $fetch 的情況

- **一次性 API 呼叫**：表單提交、即時操作
- **不需要快取的動態資料**：即時查詢結果
- **客戶端專用請求**：不需要 SSR 預載的資料

---

## 快取策略與資料新鮮度判斷

當資料請求發生時，需要判斷資料來源：

### 資料來源識別

- **初始載入**：第一次執行 useFetch 時的初始數據
- **URL 變化觸發**：因 URL 參數改變而觸發的自動刷新
- **手動刷新**：呼叫 refresh/execute 函數的手動更新
- **監聽器觸發**：通過 watch 參數變化觸發的請求

### 快取與伺服器請求選擇

根據資料特性選擇快取策略：

- **選擇快取**：使用者基本資料、系統設定、相對穩定的清單資料
- **請求伺服器**：即時數據、統計資訊、動態查詢結果

## useFetch 配置最佳實踐

### Store 中的標準配置

```typescript
const {
  data: fetchedData,
  pending: isLoading,
  error,
  execute: refresh,
  clear: clearData,
} = useFetch<DataType>('/api/endpoint', {
  baseURL: '/api',
  key: 'unique-cache-key', // 唯一快取 key，避免重複請求
  server: false, // 根據需求選擇是否在 SSR 階段執行
  immediate: false, // 手動控制執行時機
  watch: false, // 避免不必要的自動監聽
});
```

### 監聽資料變化並同步到 Store

```typescript
watch(fetchedData, (newData) => {
  if (newData) {
    storeData.value = newData;
    persistToStorage(newData); // 持久化儲存
  }
});
```

### 條件性資料獲取

```typescript
// 監聽依賴變化，有條件地觸發請求
watch(
  () => authStore.userId,
  (newUserId) => {
    if (newUserId) {
      refresh(); // 使用 execute 或 refresh 觸發請求
    }
  },
  { immediate: true }
);
```

---

## 程式碼範例

### ✅ 正確範例：Store 中使用 useFetch

```typescript
export const useDataStore = defineStore('data', () => {
  const authStore = useAuthStore();
  
  // ✅ 使用 useFetch 提供快取和 SSR 安全性
  const {
    data: userData,
    pending: isLoadingUser,
    error: userError,
    execute: refreshUser,
  } = useFetch<User>('/v1/user/profile', {
    baseURL: '/api',
    key: 'user-profile', // 唯一快取 key
    server: false, // 僅在客戶端執行
    immediate: false, // 手動控制執行
    watch: false, // 不自動監聽參數變化
  });

  // 監聽資料變化並同步
  watch(userData, (newUserData) => {
    if (newUserData) {
      user.value = newUserData;
    }
  });

  return {
    userData,
    isLoadingUser,
    userError,
    refreshUser,
  };
});
```

### ❌ 錯誤範例：Store 中使用 $fetch

```typescript
// ❌ 在 store 中直接使用 $fetch
const fetchUserData = async () => {
  try {
    loading.value = true;
    // 每次都發起新請求，沒有快取機制
    const data = await $fetch('/api/v1/user/profile');
    user.value = data;
  } catch (error) {
    console.error(error);
  } finally {
    loading.value = false;
  }
};
```

### ✅ 正確範例：表單提交使用 $fetch

```typescript
// ✅ 一次性操作使用 $fetch
const handleSubmitForm = async (formData: FormData) => {
  try {
    isSubmitting.value = true;
    await $fetch('/api/v1/form/submit', {
      method: 'POST',
      body: formData,
    });
    // 提交成功後可觸發資料刷新
    await refreshUserData();
  } catch (error) {
    handleError(error);
  } finally {
    isSubmitting.value = false;
  }
};
```

---

## 注意事項

- 在企業認證等相對穩定的資料 Store 中，優先使用 useFetch 避免路由切換時的重複請求
- 使用有意義的 key 參數來控制快取範圍，避免不同組件間的快取衝突
- 合理設定 server、immediate、watch 等參數，根據實際需求平衡效能與使用者體驗
- 對於需要即時性的資料，考慮使用適當的 refresh 策略而非完全依賴快取